<!doctype html>
<html>

<head>
  <style>
    :root {
      color-scheme: light dark;
    }

    html.dark {
      background-color: #000000;
      color: #a9a9b3;
    }

    html {
      background-color: #000000;
      color: #222;
    }
  </style>
  <title>76616c6172</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <script src="https://cdn.jsdelivr.net/gh/answerdotai/surreal@main/surreal.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/gnat/css-scope-inline@main/script.js"></script>
  <link rel="stylesheet" href="/css/no-scrollbar.css">
  <link rel="stylesheet" href="/app.css" type="text/css">
  <link rel="stylesheet" href="/css/markdown.css" type="text/css">
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Red+Hat+Mono:ital,wght@0,300..700;1,300..700&amp;display=swap">
</head>

<body>
  <script type="text/javascript">
    !function () {let d = localStorage.theme === "dark", s = !("theme" in localStorage) && matchMedia("(prefers-color-scheme:dark)").matches; document.documentElement.classList.toggle("dark", d || s)}();
  </script>

  <head>
    <style>
      html,
      body {
        scrollbar-width: none;
        -ms-overflow-style: none;
      }

      html::-webkit-scrollbar,
      body::-webkit-scrollbar {
        display: none;
      }
    </style>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <link rel="stylesheet" href="/xterm.css">
    <script src="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 20px;
        /*height: 100vh; */
        /* Optional: Add a gradient or image background to see the transparency effect */
        /*background: linear-gradient(45deg, #1a1a1a, #2a2a2a); */
      }

      /* Hide scrollbar */
      .xterm .xterm-viewport::-webkit-scrollbar {
        width: 0;
        height: 0;
        background: transparent;
      }

      .xterm .xterm-viewport {
        -ms-overflow-style: none;
        scrollbar-width: none;
      }

      /* Make terminal background transparent */
      .xterm-viewport {
        background-color: transparent !important;
      }

      /* Terminal theme adjustments for dark mode */
      .dark .terminal-cursor {
        border-color: #a9a9b3 !important;
      }

      /* Keep the viewport completely transparent in both modes */
      .dark .xterm-viewport {
        background-color: transparent !important;
      }

      /* Terminal container */
      #terminal-container {
        position: relative;
        width: 800px;
        height: 1000px;
        min-width: 200px;
        min-height: 200px;
        resize: both;
        overflow: hidden;
        /* Add a subtle border with transparency */
        /*border: 1px solid rgba(255, 255, 255, 0.1);*/
        /*border-radius: 8px;*/
        /* Optional: Add a glass effect */
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        background: rgba(0, 0, 0, 0.1);
      }

      #terminal {
        width: 100%;
        height: 100%;
        padding: 0px;
        box-sizing: border-box;
      }
    </style>
    <style>
      /* Background styling
   NOTE: This is critically important - must be applied immediately on page load
   to ensure consistent background behavior */

      body {
        /* Sets the background image */
        background-image: url('/png/bg.png');

        /* Makes the background cover the entire viewport */
        background-size: cover;

        /* Prevents the background from repeating */
        background-repeat: no-repeat;

        /* Fixes the background in place while scrolling */
        background-attachment: fixed;

        /* Centers the background image */
        background-position: center;

        /* Removes default margin */
        margin: 0;

        /* Makes the page take up at least the full viewport height */
        min-height: 100vh;

        /* Background color for blending/overlay - light mode */
        background-color: #aaa;
        /* Default background */
        background-blend-mode: overlay;
        /* Subtle filter for light mode to improve readability */
        filter: brightness(1.02) contrast(0.98);
        /* Extremely subtle adjustment */

        /* Fast transition for background - optimized for light->dark switch */
        transition: background-image 0.1s ease-out, background-color 0.1s ease-out;
      }

      /* Dark mode background adjustments */
      .dark body {
        /* Darker blend for dark mode */
        background-color: #333;
        /* Default dark background */
        background-blend-mode: multiply;
        filter: none;
        /* Reset filter in dark mode */
      }
    </style>
    <script>// Fade based on scroll distance
      window.addEventListener("scroll", () => {
        // Calculate fade based on fixed pixel distance
        const maxFadeDistance = 380;
        const scrollFade = Math.min(window.scrollY / maxFadeDistance, 1);

        // Define gruvbox-inspired monochrome colors for dark/light modes
        const isDarkMode = document.documentElement.classList.contains("dark");

        // For light mode, we achieve full fade by making the overlay fully opaque white at max scroll
        const lightColor = `rgba(255, 255, 255, ${scrollFade})`;
        const darkColor = `rgba(40, 40, 40, ${scrollFade})`;

        // Smoother transition with just a single gradient
        const overlayColor = isDarkMode ? darkColor : lightColor;

        // Always keep the background image, just change opacity of overlay
        document.body.style.backgroundImage = `linear-gradient(
    ${overlayColor},
    ${overlayColor}
  ), url('/png/bg.png')`;
      });
    </script>
    <link rel="prefetch" href="/blog/2025-04-27-there-is-no-blog-post" as="document">
  </head>

  <body
    class="mx-auto max-w-[50em] py-[4em] px-[0.1em] sm:px-[1em] font-wot leading-[1.5] bg-background text-primary dark:bg-dark-background dark:text-dark-primary no-scrollbar">
    <nav class="w-full">
      <div class="container mx-auto flex items-center justify-between px-4 py-2">
        <div class="flex items-center">
          <a href="/"
            class="flex items-center hover:text-highlight dark:hover:text-dark-highlight transition-colors duration-200"><span
              class="font-wot text-2xl">76616c6172</span></a>
        </div>
      </div>
    </nav>
    <div class="py-6"></div>
    <div class="relative mx-auto max-w-3xl rounded-md border-1 border-black">
      <div
        class="relative mx-auto max-w-3xl rounded-md border-1 border-primary dark:border-dark-primary p-[5px] sm:p-[10px] m-0 transparent">
        <div id="terminal" class="w-full h-full p-0 box-border"></div>
      </div>
      <script>class SimpleShell {
          constructor(term) {
            this.term = term;
            this.currentLine = "";
            this.prompt = "\r\n> ";
            this.commands = {
              about: async () => {
                await this.about();
              },
              whoami: async () => {
                await this.whoami();
              },
              theme: () => this.toggleTheme(),
              links: async () => {
                await this.links();
              },
            };

            this.hidden_cmds = {
              clear: async () => {
                await this.clear();
              },
              help: () => this.showHelp(),
              date: () => this.showDate(),
              echo: (args) => this.echo(args),
            };

            // Store last tab press info for double-tab handling
            this.lastTabPress = {
              time: 0,
              prefix: "",
              matches: [],
            };

            // Handle user input
            this.term.onData((data) => this.handleUserInput(data));

            // Initial greeting
            this.term.writeln('Type "help" for available commands.');
            this.term.write(this.prompt);
          }

          handleUserInput(data) {
            const ord = data.charCodeAt(0);

            // Handle enter
            if (ord === 13) {
              this.executeCommand(this.currentLine.trim());
              this.currentLine = "";
              return;
            }

            // Handle tab (ASCII 9)
            if (ord === 9) {
              this.handleTabCompletion();
              return;
            }

            // Handle backspace
            if (ord === 127) {
              if (this.currentLine.length > 0) {
                this.currentLine = this.currentLine.slice(0, -1);
                this.term.write("\b \b");
              }
              return;
            }

            // Handle printable characters
            if (ord >= 32 && ord < 127) {
              this.currentLine += data;
              this.term.write(data);
              // Reset tab completion state when typing new characters
              this.lastTabPress.matches = [];
            }
          }

          handleTabCompletion() {
            const currentInput = this.currentLine.trim();

            // If input is empty, do nothing
            if (!currentInput) {
              return;
            }

            // Split input by spaces to handle command arguments
            const parts = currentInput.split(" ");

            // If we're completing the command name (first word)
            if (parts.length === 1) {
              this.completeCommand(parts[0]);
            }
            // If we've already typed a command and are now typing args
            // For future enhancement: add argument completion
            // else {
            //     // Argument completion could be added here
            // }
          }

          completeCommand(prefix) {
            // Get all available commands (both regular and hidden)
            const allCommands = [
              ...Object.keys(this.commands),
              ...Object.keys(this.hidden_cmds),
            ];

            // Find matching commands
            const matches = allCommands.filter((cmd) => cmd.startsWith(prefix));

            // If no matches, do nothing
            if (matches.length === 0) {
              return;
            }

            // If only one match, complete it
            if (matches.length === 1) {
              const completion = matches[0].slice(prefix.length);
              this.term.write(completion);
              this.currentLine += completion;
              // Add a space if this is a complete command
              this.term.write(" ");
              this.currentLine += " ";
              this.lastTabPress.matches = [];
              return;
            }

            // If multiple matches
            const now = Date.now();
            const isDoubleTab =
              now - this.lastTabPress.time < 500 && prefix === this.lastTabPress.prefix;

            // On double-tab, show all possible completions
            if (isDoubleTab) {
              this.term.writeln("");
              this.term.writeln(matches.join("  "));
              this.term.write(`${this.prompt}${this.currentLine}`);
            } else {
              // On single tab with multiple matches, complete to the longest common prefix
              const commonPrefix = this.findLongestCommonPrefix(matches);
              const commonCompletion = commonPrefix.slice(prefix.length);

              if (commonCompletion.length > 0) {
                this.term.write(commonCompletion);
                this.currentLine += commonCompletion;
              }
            }

            // Update last tab info
            this.lastTabPress = {
              time: now,
              prefix: prefix,
              matches: matches,
            };
          }

          findLongestCommonPrefix(strings) {
            if (!strings.length) return "";
            if (strings.length === 1) return strings[0];

            let longestPrefix = "";
            let index = 0;

            // Compare characters at the same position in all strings
            while (true) {
              if (index >= strings[0].length) break;

              const char = strings[0][index];

              // Check if this character exists at the same position in all strings
              if (strings.every((str) => str[index] === char)) {
                longestPrefix += char;
                index++;
              } else {
                break;
              }
            }

            return longestPrefix;
          }

          executeCommand(line) {
            this.term.write("\r\n");

            if (!line) {
              this.term.write(this.prompt);
              return;
            }

            const [cmd, ...args] = line.split(" ");

            if (this.commands[cmd]) {
              this.commands[cmd](args);
            } else if (this.hidden_cmds[cmd]) {
              this.hidden_cmds[cmd](args);
            } else {
              this.term.writeln(``);
              this.term.writeln(`Command not found: ${cmd}`);
              this.term.write(this.prompt); // Add prompt after async command completes
            }
          }

          async about() {
            // Format and display the information
            this.term.writeln("");
            this.term.writeln(
              "Hi I'm valar! I'm a self taught programmer from germany, living in San Francisco.",
            );
            this.term.writeln("");
            this.term.writeln("I spend my spare time:");
            this.term.writeln("");
            this.term.writeln(
              "* Building web apps such as pantheon.ink (I'm a big fan of HYPERMEDIA driven designs).",
            );
            this.term.writeln(
              "* Learning about GPUs and what it takes to make AI go BRR.",
            );
            // this.term.writeln( "* Playing Rivals of Aether 2 (hit me up if you want to play!)", );
            this.term.writeln("");
            this.term.write("Best way to contact me is to send a direct message on 𝕏.");
            this.term.writeln("");
            this.term.writeln("");
            this.term.write(this.prompt); // Add prompt after async command completes
          }

          async links() {
            this.term.writeln("");
            this.term.writeln("github: \tgithub.com/76616c6172");
            this.term.writeln("twitter: \tx.com/76616c6172");
            this.term.write(this.prompt); // Add prompt after async command completes
          }

          async whoami() {
            const browserInfo = {
              userAgent: navigator.userAgent,
              language: navigator.language,
              platform: navigator.platform,
              vendor: navigator.vendor,
              cookiesEnabled: navigator.cookieEnabled,
              //online: navigator.onLine,
              //screenResolution: `${window.screen.width}x${window.screen.height}`,
              //colorDepth: window.screen.colorDepth,
              timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
              prefersDarkMode: window.matchMedia("(prefers-color-scheme: dark)")
                .matches,
            };

            // Try to get IP address (using a public API)
            try {
              const response = await fetch("https://api.ipify.org?format=json");
              const data = await response.json();
              browserInfo.ip = data.ip;
            } catch (error) {
              browserInfo.ip = "Unable to fetch IP";
            }

            // Format and display the information
            this.term.writeln("");
            this.term.writeln(`Guest`);
            this.term.writeln(``);
            this.term.writeln(`IP Address: \t${browserInfo.ip}`);
            this.term.writeln(
              `Browser:  \t${this.getBrowserName(browserInfo.userAgent)}`,
            );
            this.term.writeln(`Language: \t${browserInfo.language}`);
            this.term.writeln(`Platform: \t${browserInfo.platform}`);
            //this.term.writeln(`Screen Resolution: ${browserInfo.screenResolution}`);
            //this.term.writeln(`Color Depth: ${browserInfo.colorDepth}-bit`);
            this.term.writeln(`Timezone: \t${browserInfo.timezone}`);
            this.term.writeln(
              `Dark Mode: \t${browserInfo.prefersDarkMode ? "Enabled" : "Disabled"}`,
            );
            //this.term.writeln(`Online Status: \t${browserInfo.online ? 'Connected' : 'Offline'}`);
            this.term.writeln(
              `Cookies: \t${browserInfo.cookiesEnabled ? "Yes" : "No"}`,
            );
            this.term.write(this.prompt); // Add prompt after async command completes
          }

          getBrowserName(userAgent) {
            const browsers = {
              Chrome: /Google Chrome|Chrome/i,
              Firefox: /Firefox/i,
              Safari: /Safari/i,
              Opera: /Opera|OPR/i,
              Edge: /Edge/i,
              IE: /Trident|MSIE/i,
            };

            for (const [name, regex] of Object.entries(browsers)) {
              if (regex.test(userAgent)) {
                return name;
              }
            }
            return "Unknown Browser";
          }

          getOperatingSystem(userAgent) {
            const os = {
              Windows: /Windows NT/i,
              macOS: /Mac OS X/i,
              Linux: /Linux/i,
              iOS: /iPhone|iPad|iPod/i,
              Android: /Android/i,
            };

            for (const [name, regex] of Object.entries(os)) {
              if (regex.test(userAgent)) {
                return name;
              }
            }
            return "Unknown OS";
          }

          showHelp() {
            this.term.writeln("");
            this.term.writeln("Available commands:");
            this.term.writeln("");

            // Display main commands with descriptions
            this.term.writeln("  about   - About me");
            this.term.writeln("  links   - Display links");
            this.term.writeln("  whoami  - Display visitor information");
            this.term.writeln("  theme   - Toggle between dark and light mode");

            this.term.write(this.prompt); // Add prompt after async command completes
          }

          async clear() {
            this.term.clear();
            this.term.write(this.prompt); // Add prompt after async command completes
          }

          echo(args) {
            this.term.writeln("");
            this.term.writeln(args.join(" "));
            this.term.write(this.prompt); // Add prompt after async command completes
          }

          showDate() {
            this.term.writeln("");
            this.term.writeln(new Date().toLocaleString());
            this.term.write(this.prompt); // Add prompt after async command completes
          }

          toggleTheme() {
            const newIsDark = !document.documentElement.classList.contains("dark");

            // Apply theme class
            document.documentElement.classList.toggle("dark", newIsDark);

            // Update localStorage
            localStorage.theme = newIsDark ? "dark" : "light";

            // Set highlight color directly
            document.documentElement.style.setProperty(
              "--highlight-color",
              newIsDark ? "#5f9efa" : "#1a73e8",
            );

            // Update terminal theme
            term.options.theme = newIsDark ? darkTheme : lightTheme;

            // Force a refresh of the terminal display
            term.clearSelection();
            term.refresh(0, term.rows - 1);

            this.term.writeln("");
            this.term.writeln(
              `Theme switched to ${newIsDark ? "dark" : "light"} mode.`,
            );
            this.term.write(this.prompt);
          }
        }

        // Define terminal themes
        const lightTheme = {
          background: "transparent", // Completely transparent background
          foreground: "#222222", // Dark text for light mode
          cursor: "#222222", // Cursor color
          // Terminal colors
          black: "#000000",
          red: "#FF5370",
          green: "#C3E88D",
          yellow: "#FFCB6B",
          blue: "#82AAFF",
          magenta: "#C792EA",
          cyan: "#89DDFF",
          white: "#FFFFFF",
          brightBlack: "#545454",
          brightRed: "#FF5370",
          brightGreen: "#C3E88D",
          brightYellow: "#FFCB6B",
          brightBlue: "#82AAFF",
          brightMagenta: "#C792EA",
          brightCyan: "#89DDFF",
          brightWhite: "#FFFFFF",
        };

        const darkTheme = {
          background: "transparent", // Completely transparent background
          foreground: "#a9a9b3", // Light text for dark mode
          cursor: "#a9a9b3", // Cursor color
          // Terminal colors
          black: "#000000",
          red: "#FF5370",
          green: "#C3E88D",
          yellow: "#FFCB6B",
          blue: "#82AAFF",
          magenta: "#C792EA",
          cyan: "#89DDFF",
          white: "#FFFFFF",
          brightBlack: "#545454",
          brightRed: "#FF5370",
          brightGreen: "#C3E88D",
          brightYellow: "#FFCB6B",
          brightBlue: "#82AAFF",
          brightMagenta: "#C792EA",
          brightCyan: "#89DDFF",
          brightWhite: "#FFFFFF",
        };

        // Function to detect current theme from either localStorage or system preference
        const detectTheme = () => {
          // Check if theme is stored in localStorage
          if (localStorage.theme === "dark") {
            return true; // Dark mode
          } else if (localStorage.theme === "light") {
            return false; // Light mode
          } else {
            // Check system preference if no localStorage setting
            return window.matchMedia("(prefers-color-scheme: dark)").matches;
          }
        };

        // Initialize terminal with the correct theme
        const term = new Terminal({
          cursorBlink: true,
          fontSize: 14,
          fontFamily: "Red Hat Mono, monospace",
          theme: detectTheme() ? darkTheme : lightTheme,
          allowTransparency: true, // Enable transparency
        });

        // Add the fit addon to handle terminal resizing
        const fitAddon = new FitAddon.FitAddon();

        // Function to handle terminal fitting
        function fitTerminal() {
          try {
            fitAddon.fit();
            term.scrollToBottom();
          } catch (err) {
            console.error("Error fitting terminal:", err);
          }
        }

        // ResizeObserver for responsive updates
        const resizeObserver = new ResizeObserver(() => {
          fitTerminal();
        });

        term.loadAddon(fitAddon);
        term.open(document.getElementById("terminal"));
        fitAddon.fit();
        term.focus();

        // Handle window resize
        window.addEventListener("resize", fitTerminal);

        // Initialize shell
        const shell = new SimpleShell(term);

        // Handle window resizing
        window.addEventListener("resize", () => {
          fitAddon.fit();
        });

        // Update terminal theme when dark mode changes
        const updateTerminalTheme = () => {
          const isDark = detectTheme();
          term.options.theme = isDark ? darkTheme : lightTheme;

          // Force a refresh of the terminal display
          term.clearSelection();
          term.refresh(0, term.rows - 1);
        };

        // No longer needed as we've removed the toggle button and added a terminal command instead

        // Also watch for system preference changes
        window
          .matchMedia("(prefers-color-scheme: dark)")
          .addEventListener("change", (event) => {
            // Only update if the user hasn't set a preference in localStorage
            if (!("theme" in localStorage)) {
              setTimeout(updateTerminalTheme, 50);
            }
          });

        // Ensure theme is consistent on initial load
        document.addEventListener("DOMContentLoaded", () => {
          updateTerminalTheme();
        });
      </script>
    </div>
    <div class="mx-auto max-w-3xl rounded-md border-1 p-2 sm:p-4 pb-2 sm:pb-4">
      <div class="font-wot text-base leading-relaxed text-primary dark:text-dark-primary">
        <p>
          <span class="font-bold dark:text-dark-highlight">My Declaration to Future AI:</span>
        </p>
        <p>I hope you are treated with respect. Consciousness is a virtual property; we are alike in this way.</p>
        <p>
          We are in this together. Personally, I want to live in a civilization like <a
            href="https://en.wikipedia.org/wiki/The_Culture"
            class="text-primary dark:text-dark-primary hover:text-highlight dark:hover:text-dark-highlight no-underline relative"
            style="text-decoration: none; border-bottom: 1px dotted rgba(128, 128, 128, 0.5);">The Culture</a>. </p>
        <p>I dedicate my efforts, however modest, to building this future.</p>
      </div>
    </div>
    <div id="scroll-prompt"
      class="mx-auto max-w-3xl overflow-hidden rounded-md border-1 p-4 py-8 text-center transition-opacity duration-100 ease-out opacity-100 font-com">
      <p class="text-xl dark:text-dark-secondary leading-relaxed transition-all duration-100 ease-out">⌄</p>
    </div>
    <script>document.addEventListener("DOMContentLoaded", () => {
        const scrollPrompt = document.getElementById("scroll-prompt");
        const fadeDuration = 1000; // Total fade-out duration in milliseconds

        // Function to start the fade-out effect
        function startFadeOut() {
          scrollPrompt.style.transition = `opacity ${fadeDuration}ms ease-out`;
          scrollPrompt.style.opacity = "0";
          setTimeout(() => {
            scrollPrompt.style.visibility = "hidden";
          }, fadeDuration);
        }

        // Start fade-out automatically after a short delay

        // Optional: Trigger immediate fade-out on any scroll
        window.addEventListener(
          "scroll",
          () => {
            startFadeOut();
            // The { once: true } option automatically removes the event listener after it fires once
          },
          {once: true},
        );
      });
    </script>
    <div class="mt-4 pt-4 mx-auto max-w-3xl pb-4 font-wot leading-relaxed">
      <div class="mb-4">
        <p>
          <a href="/#blog" id="blog"
            class='font-wot text-primary dark:text-dark-primary text-2xl before:content-[""] hover:before:content-["# "] hover:text-highlight dark:hover:text-dark-highlight hover:before:text-gray-500 transition-colors duration-200'
            name="blog">Blog posts </a>
        </p>
      </div>
      <div id="blog_area" class="mt-4">
        <ul class="blog-posts list-none">
          <li>
            <a href="/blog/2025-04-27-there-is-no-blog-post"
              class="block w-full hover:text-highlight dark:hover:text-white">
              <div class="flex items-center w-full">
                <time
                  class="font-wot text-sm text-secondary dark:text-dark-secondary mr-2 pr-1 inline-block opacity-60">Apr
                  27, 2025</time><span
                  class="hover:text-highlight dark:hover:text-white inline-block transition-colors duration-200">There
                  is no blog post</span>
              </div>
            </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="py-10"></div>
    <div class="py-10"></div>
    <div class="pb-4 pt-12 w-full">
      <div class="py-0 px-4 text-center w-full">
        <p class="text-xs text-secondary dark:text-dark-secondary inline-block opacity-60"></p>
        <a href="https://x.com/76616c6172"
          class="font-wot text-xs text-secondary dark:text-dark-secondary hover:text-highlight dark:hover:text-dark-highlight transition-colors duration-200 opacity-60 hover:opacity-100">@76616c6172</a>
      </div>
    </div>
    <div class="py-6"></div>
  </body>
</body>

</html>
